### 一、 Testbench 标准结构规范

一个专业的 TB 应该具备清晰的层次感，通常包含以下五个部分：

1. **时间尺度与信号定义**：
   - 必须包含 ``timescale 1ns/1ps` 。
   - 待测模块（DUT）的输入定义为 `reg`，输出定义为 `wire` 。
2. **例化待测模块 (Instantiation)**：
   - 建议使用**名字关联（Named Mapping）**而不是位置关联，以提高代码的可读性和维护性。
3. **时钟与复位生成 (Clock & Reset)**：
   - 时钟生成使用 `forever` 语句。
   - 复位逻辑必须包含初置为 0、延迟后释放为 1 的过程。
4. **激励驱动 (Stimulus Generation)**：
   - 在 `initial` 块中编写逻辑，建议复杂的重复操作封装为 `task` 以便复用。
5. **结果监控与自动比对 (Self-Checking)**：
   - 使用 `$display` 打印关键信息，并用 `if...else` 逻辑实现自动报错，而不是仅靠眼睛看波形。

------

### 二、 核心注意事项：时序与采样

这是你目前最需要注意的部分，尤其是在处理像 FWFT FIFO 这样带有**组合逻辑**路径的模块时：

- **采样点选择**：
  - **组合逻辑输出（如 FWFT `dout`）**：必须在触发跳转的**同一个时钟沿**（或延迟一个极小时间 `#1`）进行采样，否则会读到下一拍的数据。
  - **时序逻辑输出**：应在触发跳转后的**下一个时钟沿**采样。
- **非阻塞赋值的使用**：
  - 在 TB 中驱动 DUT 输入时，推荐使用 `reg_in <= data;`（非阻塞赋值），这能模拟真实的寄存器输出时序，避免仿真器中的竞争冒险。
- **避免使用绝对延时 `#` 控制逻辑**：
  - 除了复位释放和时钟生成，尽量使用 `@(posedge clk)` 来驱动信号，确保激励与硬件时钟同步。

------

### 三、 工业级 TB 的进阶建议

1. **分层 Filelist 配合**：
   - 确保 TB 的命名与 `.f` 文件、Makefile 变量保持一致，实现自动化一键仿真。
2. **异常边界测试**：
   - 除了测试正常功能，必须测试“非法操作”。例如：在 FIFO 满时继续写，或在 FIFO 空时尝试读。
3. **参数化验证**：
   - 在 TB 中定义 `parameter` 或 `localparam` ，使验证环境能随 RTL 宽度或深度的变化而自动调整。
4. **波形记录 (Waveform Dumping)**：
   - 使用 `$fsdbDumpfile` 和 `$fsdbDumpvars` 记录波形 ，这是在 Verdi 中进行调试的基础。

------

### 四、 总结：你的项目实操清单

针对你的 **APB UART 项目**，在写接下来的系统级 TB 时请对照此表：

| **检查项**       | **实现要点**                                                 |
| ---------------- | ------------------------------------------------------------ |
| **复位逻辑**     | 确保 `PRESETn` 至少保持 2 个以上的 `PCLK` 周期。             |
| **APB 协议模拟** | 严格区分 `SETUP`（`PENABLE`为0）和 `ACCESS`（`PENABLE`为1）阶段。 |
| **FIFO 监测**    | 重点观察 `data_ack` 脉冲产生时，`tx_dout_fifo` 的数据是否正确被 `uart_tx` 捕获 16。 |
| **中断 W1C**     | 验证向 `REG_UART_INT` 写入 1 后，中断标志是否真的消失 17。   |

